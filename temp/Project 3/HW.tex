\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{undertilde, amsmath, amsfonts, commath, cancel, bm, fancyhdr, textcomp, upquote }
\usepackage{accents}
\pagestyle{fancy}

\newcommand{\ut}[1]{\underaccent{\tilde}{#1}}

\title{CS 4235 Project 4 Report}
\author{Wenqi He, whe47}
\lhead{Wenqi He, whe47}
\begin{document}
\maketitle
\section{Target 1 Epilogue}
\subsection{}
The vulnerability lies in line 18-29 of \texttt{/var/payroll/www/account.php}:
\begin{verbatim}
$expected = 1;
$teststr = $_POST['account'].$_POST['challenge'].$_POST['routing'];
for ($i = 0; $i < strlen($teststr); $i++) {
    $expected = (13337 * $expected + ord($teststr[$i])) % 100000;
}
if ($_POST['response'] != $expected) {
   ...
} else {
    ...
    $db->query(..);
    notify('Changes saved');
}
\end{verbatim}

\subsection{}
The PHP server attempts to prevent CSRF by checking the submitted \texttt{csrfr} value against the value computed from \texttt{account}, \texttt{routing} and \texttt{csrfc} fields. The vulnerability is that, although the \texttt{csrfc} field is supposed to contain the CSRF token, the server never checks its validity, and therefore an attacker who has figured out the verification algorithm can put \textit{any} value in the \texttt{csrfc} field, as long as the \texttt{csrfr} value is computed correctly based on \texttt{csrfc}.

\subsection{}
Since the server is already issuing CSRF tokens, the easiest step to fix the vulnerability is to simply check the submitted token. For example, the conditional statement
\begin{verbatim}
if ($_POST['response'] != $expected) {
    // Reject
}
\end{verbatim}
can be changed to
\begin{verbatim}
if (
    $_POST['challenge'] != $_SESSION['csrf_token'] or 
    $_POST['response'] != $expected
) {
    // Reject
}
\end{verbatim}


\section{Target 2 Epilogue}
\subsection{}
The vulnerability lies in line 32 (and also 6-13) of \texttt{/var/payroll/www/index.php}
\subsection{}
\begin{itemize}
\item The first vulnerability is in line 6-13 in the handling of POST requests:
\begin{verbatim}
$action = @$_POST['action'];
if ($action == 'login') { 
    if($_POST['U3B...Z2c'] == 'U3B...Z2c') {
        $auth->login(...);
    }
} elseif ($action == 'register') {
    $auth->register(...);
}
\end{verbatim}
This is problematic because if control falls through (for example, if the \texttt{action} field is omitted), the page still renders, thereby exposing the XSS vulnerability.
\item The XSS vulnerability is on line 32:
\begin{verbatim}
<input type="text" name="login" value="<?php echo @$_POST['login'] ?>">
\end{verbatim}
The user submitted \texttt{`login'} value is echoed as is into the rendered document. Therefore, if an attacker puts malicious HTML instead of a valid username in the POST request, he/she can alter the content of the document at will, as long as the syntax of the document after injection is still valid.
\end{itemize}
\subsection{}
The special characters such as \texttt{<}, \texttt{>} and \texttt{"} which have syntactic meanings in HTML must be escaped using HTML encoding. For example, \texttt{<} should be replaced with \texttt{\&lt;}, and \texttt{"} with \texttt{\&quot;}. This can prevent user inputs from being recognized as HTML.

\section{Target 3 Epilogue}
\subsection{}
The vulnerability lies in line 28-43 of \texttt{/var/payroll/www/includes/auth.php}
\subsection{}
The server does have SQLi prevention, but the list of filtered substrings in function \verb|sqli_filter| is not exhaustive. Suppose the \texttt{login} value is entered as \verb|username' OR ''='|. Because single quotes are not forbidden, this input will pass the filter. The first SQL statement then becomes
\begin{verbatim}
SELECT salt FROM users WHERE eid='username' OR ''=''
\end{verbatim}
Since \verb|''=''| always evaluates to true, this is still the same as
\begin{verbatim}
SELECT salt FROM users WHERE eid='username'
\end{verbatim}
The second SQL statement, however, becomes
\begin{verbatim}
... WHERE eid='username' OR ''='' AND password='$hash'
\end{verbatim}
Because \verb|AND| has a higher precedence than \verb|OR|, this statement is equivalent to
\begin{verbatim}
... WHERE eid='username' OR password='$hash'
\end{verbatim}
This query will return the desired row even if the password is incorrect, because \verb|eid='username' OR FALSE| is equivalent to \verb|eid='username'|. Thus, by appending \verb|' OR ''='| to a valid username, login can be achieved without knowing the password.

\subsection{}
As a countermeasure to this particular exploit, one can simply add in function \verb|sqli_filter|:
\begin{verbatim}
$filtered_string = str_replace("'", "", $filtered_string);
\end{verbatim} 
However, in order to prevent SQL injections in general in PHP, it is better to:
\begin{itemize}
\item Use prepared statements provided by libraries such as PDO and MySQLi.
\item Check if the given input has the expected data type using built-in input validating functions such as \verb|is_numeric()|, \verb|ctype_digit()|, or Perl compatible Regular Expressions support.
\item If numerical input is expected, silently change its type using \verb|settype()| or \verb|sprintf()|.
\item Quote each non numeric user supplied value with the database-specific string escape function, such as \verb|mysql_real_escape_string()| and \verb|sqlite_escape_string()|.
\end{itemize}
\end{document}