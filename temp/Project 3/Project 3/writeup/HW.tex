\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{undertilde, amsmath, amsfonts, commath, cancel, bm}
\usepackage{accents}

\newcommand{\ut}[1]{\underaccent{\tilde}{#1}}

\title{CS 4235 Project 3 Report}
\author{Wenqi He}
\begin{document}
\maketitle
\section*{Task 2}
\subsection*{a}
Yes, the hash is still vulnerable, because the salt is chosen from a small space that can be easily traversed. If cracking an unsalted password requires worst-case $\mathcal{O}(n)$ time, then cracking a password salted this way would just require $\mathcal{O}(n^2)$ time, which is certainly harder but still feasible.
\subsection*{b}
One way to enhance security is to generate random strings rather than using commonly used passwords as salts. That way an attacker would need to try all possible combinations of characters, which would be exponentially more difficult. Adding a second salt/pepper could enhance security as well.
\section*{Task 3}
\subsubsection*{Step I - Factor $n$ into a pair of prime divisors $p, q$} This was done through a brute-force linear search since there is no known algorithm to compute prime factors directly. Optimization was made based on the fact that
\[ \min\{p,q\} \in \big(1, \lceil n^{1/2} \rceil\big]\]
and the two primes are less likely to be closer to $1$. The search for $p$ starts from $\lceil n^{1/2} \rceil$ and proceeds down to $2$. If $p$ divides $n$, $p$ and $n/p$ are returned as the factors.
\subsubsection*{Step II - Compute the private key from $p,q,e$} First the Euler's totient function was computed as the modulus:
\[ \phi(n) = \phi(pq) = \phi(p)\phi(q) = (p-1)(q-1) \]
The fact that $ed \equiv 1 \pmod{\phi}$ implies that $gcd(e,\phi) =1$, because otherwise $d$ wouldn't have a modular multiplicative inverse. Therefore, this congruence could be expressed as the BÃ©zout's identity, where $d, k$ are the coefficients for $e, \phi$, respectively:
\[ 1 - ed = k\phi \quad\Rightarrow\quad \bm{e}d + \bm{\phi}k = 1 = \bm{gcd(e,\phi)} \]
The private key $d$ (along with $k$) was then obtained using the extended Euclidean algorithm.
\section*{Task 4}
\subsection*{a}
The moduli generated contain common prime factors, which trivializes factorization.
As before, obtaining the private key still requires first factoring $N1$ into $p,q$ and then computing $d$ using the extended Euclidean algorithm. However, this time factorization is easy, because computing $gcd(N1,N2)$ amounts to factoring both $N1$ and $N2$, provided that they share a common prime factor. 
\subsection*{b}
\subsubsection*{Step I - Factor $N1$ into primes $p, q$ using $N2$}
\[p = gcd(N1, N2), \quad q = N1/p \]
\subsubsection*{Step II - Compute the private key from $p,q,e$} This step is exactly the same as before.


\section*{Task 5}
\subsection*{a}
According to the RSA encryption algorithm, the three ciphertexts can be expressed as
\[ C_i = M^3 \bmod{N_i},\quad i = 1,2,3 \]
Or equivalently, as congruences:
\[ M^3 \equiv  C_i \pmod{N_i},\quad i = 1,2,3 \]
According to the Chinese remainder theorem, given a set of simultaneous congruences
\[ x \equiv a_i \pmod{n_i}, \quad 1 \leq i \leq r \]
where $n_i$ are pairwise relatively prime, $x \pmod{N}$ is uniquely determined:
\[ x \equiv \sum_{i=1}^{r}a_iM_iN_i \pmod{N} \tag{$\star$}\]
where
\[ N = \prod_{i=1}^r n_i,\quad N_i = \frac{N}{n_i}, \quad M_i N_i \equiv 1 \pmod{n_i} \]
\textit{Proof}: For arbitrary $1 \leq k \leq r$,
\[ x\bmod{n_k} = \Big(\sum_{i=1}^{r}a_iM_iN_i\Big) \bmod{n_k} = \Big(a_kM_kN_k\Big) \bmod{n_k} = a_k \]
Thus, the message can be recovered, assuming that $N_i$ are pairwise relatively prime.
\subsection*{b}
\subsubsection*{Step I - Obtain $M^3$ using formula ($\star$)}
\subsubsection*{Step II - Take the cubic root of $M^3$ to recover the message} Ideally this could be done as \verb|pow(m_cubed, 1/3)|, but since $M^3$ is too big for the built-in \verb|pow()| function to handle, this step was implemented using a binary search instead.

\end{document}